<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sai Common: SaiCommon::LoopTimer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Sai Common<span id="projectnumber">&#160;v1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSaiCommon.html">SaiCommon</a></li><li class="navelem"><a class="el" href="classSaiCommon_1_1LoopTimer.html">LoopTimer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSaiCommon_1_1LoopTimer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SaiCommon::LoopTimer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class implements a precise timer to run a loop at a specified frequency, and provide monitoring options for the loop runtimes.  
 <a href="classSaiCommon_1_1LoopTimer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LoopTimer_8h_source.html">LoopTimer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24713e4825ca143cb28281518627871c" id="r_a24713e4825ca143cb28281518627871c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a24713e4825ca143cb28281518627871c">LoopTimer</a> (double frequency, unsigned int initial_wait_nanoseconds=0)</td></tr>
<tr class="memdesc:a24713e4825ca143cb28281518627871c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Loop Timer with the specified frequency and initial wait time before starting the first loop.  <br /></td></tr>
<tr class="separator:a24713e4825ca143cb28281518627871c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e44d0eb0db304764b544fdcb36a194" id="r_ab0e44d0eb0db304764b544fdcb36a194"><td class="memItemLeft" align="right" valign="top"><a id="ab0e44d0eb0db304764b544fdcb36a194" name="ab0e44d0eb0db304764b544fdcb36a194"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LoopTimer</b> (const <a class="el" href="classSaiCommon_1_1LoopTimer.html">LoopTimer</a> &amp;)=delete</td></tr>
<tr class="separator:ab0e44d0eb0db304764b544fdcb36a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda011e4f777c0e384e1ae8df3f2dccf" id="r_acda011e4f777c0e384e1ae8df3f2dccf"><td class="memItemLeft" align="right" valign="top"><a id="acda011e4f777c0e384e1ae8df3f2dccf" name="acda011e4f777c0e384e1ae8df3f2dccf"></a>
<a class="el" href="classSaiCommon_1_1LoopTimer.html">LoopTimer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classSaiCommon_1_1LoopTimer.html">LoopTimer</a> &amp;)=delete</td></tr>
<tr class="separator:acda011e4f777c0e384e1ae8df3f2dccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cccca80748ea9ab1ad43cbd18fd12ec" id="r_a3cccca80748ea9ab1ad43cbd18fd12ec"><td class="memItemLeft" align="right" valign="top"><a id="a3cccca80748ea9ab1ad43cbd18fd12ec" name="a3cccca80748ea9ab1ad43cbd18fd12ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTimerName</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a3cccca80748ea9ab1ad43cbd18fd12ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da72aa5dac934e9a28daab42870cb83" id="r_a7da72aa5dac934e9a28daab42870cb83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a7da72aa5dac934e9a28daab42870cb83">resetLoopFrequency</a> (double frequency)</td></tr>
<tr class="memdesc:a7da72aa5dac934e9a28daab42870cb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the loop frequency.  <br /></td></tr>
<tr class="separator:a7da72aa5dac934e9a28daab42870cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbb552aea547d89c4ca36b62e94315d" id="r_acfbb552aea547d89c4ca36b62e94315d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#acfbb552aea547d89c4ca36b62e94315d">reinitializeTimer</a> (unsigned int initial_wait_nanoseconds=0)</td></tr>
<tr class="memdesc:acfbb552aea547d89c4ca36b62e94315d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the timer.  <br /></td></tr>
<tr class="separator:acfbb552aea547d89c4ca36b62e94315d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c33acfc3adf03d8f386d83f6d7824d7" id="r_a5c33acfc3adf03d8f386d83f6d7824d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a5c33acfc3adf03d8f386d83f6d7824d7">waitForNextLoop</a> ()</td></tr>
<tr class="memdesc:a5c33acfc3adf03d8f386d83f6d7824d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for next loop. Use in your while loop. Not needed if using <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">LoopTimer::run()</a>. If overtine monitoring is enabled, this function will return false in case the overtime monitoring conditions are not satisfied and true otherwise. If no overtime monitoring is enabled, this will return true if the timer waited and false otherwise.  <br /></td></tr>
<tr class="separator:a5c33acfc3adf03d8f386d83f6d7824d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8927cd9e6afbd1272d446f1570a5c803" id="r_a8927cd9e6afbd1272d446f1570a5c803"><td class="memItemLeft" align="right" valign="top"><a id="a8927cd9e6afbd1272d446f1570a5c803" name="a8927cd9e6afbd1272d446f1570a5c803"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><b>elapsedCycles</b> ()</td></tr>
<tr class="memdesc:a8927cd9e6afbd1272d446f1570a5c803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of full loops completed since calling run, or number of times the waitForNextLoop function was called. <br /></td></tr>
<tr class="separator:a8927cd9e6afbd1272d446f1570a5c803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9007054135a9cacf52f8eb82015a2c1" id="r_ab9007054135a9cacf52f8eb82015a2c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#ab9007054135a9cacf52f8eb82015a2c1">elapsedTime</a> ()</td></tr>
<tr class="memdesc:ab9007054135a9cacf52f8eb82015a2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elapsed real time (from computer cpu clock) since the timer started.  <br /></td></tr>
<tr class="separator:ab9007054135a9cacf52f8eb82015a2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bc8867b871b65c153ab46c6d61716f" id="r_a47bc8867b871b65c153ab46c6d61716f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a47bc8867b871b65c153ab46c6d61716f">elapsedSimTime</a> ()</td></tr>
<tr class="memdesc:a47bc8867b871b65c153ab46c6d61716f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elapsed "simulation" time since the timer started. This corresponds to the theoretical time that should have been elapsed if the loop was running at the desired frequency, and is computed from the number of epapsed cycles and the frequency of the loop.  <br /></td></tr>
<tr class="separator:a47bc8867b871b65c153ab46c6d61716f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd893de5dca6597dbdf0832340e87c1" id="r_a2fd893de5dca6597dbdf0832340e87c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a2fd893de5dca6597dbdf0832340e87c1">enableOvertimeMonitoring</a> (const double max_overtime_ms, const double max_average_overtime_ms, const double percentage_overtime_loops_allowed, const bool print_warning=false)</td></tr>
<tr class="memdesc:a2fd893de5dca6597dbdf0832340e87c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables overtime monitoring. Allows a monitoring of the overtime of the loop and makes the function waitForNextLoop return false if: 1 - the latest loop overtime is higher than max_time_ms 2 - the average loop overtime is higher than max_average_time_ms 3 - the percentage of loops with overtime is higher than percentage_allowed.  <br /></td></tr>
<tr class="separator:a2fd893de5dca6597dbdf0832340e87c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5bbd1aa43c7e87ac7efb42e2f0177" id="r_a9fb5bbd1aa43c7e87ac7efb42e2f0177"><td class="memItemLeft" align="right" valign="top"><a id="a9fb5bbd1aa43c7e87ac7efb42e2f0177" name="a9fb5bbd1aa43c7e87ac7efb42e2f0177"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printInfoPostRun</b> ()</td></tr>
<tr class="memdesc:a9fb5bbd1aa43c7e87ac7efb42e2f0177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a summary of the loop timer at the current time, or until the stip function was called. It will print info such as the desired running frequency, the actual one, the elapsed time and elapsed sim time, and some overtime monitoring info. <br /></td></tr>
<tr class="separator:a9fb5bbd1aa43c7e87ac7efb42e2f0177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f70b24a9a22d85bb558beb28441ea96" id="r_a0f70b24a9a22d85bb558beb28441ea96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96">run</a> (void(*userCallback)(void))</td></tr>
<tr class="memdesc:a0f70b24a9a22d85bb558beb28441ea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a loop that calls the user_callback(). Blocking function.  <br /></td></tr>
<tr class="separator:a0f70b24a9a22d85bb558beb28441ea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359c7b5ddf4356aebe8fe309cb5105a1" id="r_a359c7b5ddf4356aebe8fe309cb5105a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a359c7b5ddf4356aebe8fe309cb5105a1">stop</a> ()</td></tr>
<tr class="memdesc:a359c7b5ddf4356aebe8fe309cb5105a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the loop, started by <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">run()</a>. Use within callback, or from a seperate thread.  <br /></td></tr>
<tr class="separator:a359c7b5ddf4356aebe8fe309cb5105a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2db79825ee463c713b70b34a0aa8c1d4" id="r_a2db79825ee463c713b70b34a0aa8c1d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiCommon_1_1LoopTimer.html#a2db79825ee463c713b70b34a0aa8c1d4">setCtrlCHandler</a> (void(*userCallback)(int))</td></tr>
<tr class="memdesc:a2db79825ee463c713b70b34a0aa8c1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Ctrl C Handler object (untested)  <br /></td></tr>
<tr class="separator:a2db79825ee463c713b70b34a0aa8c1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f78972936e80cb88f05db932c3d1c" id="r_a8f7f78972936e80cb88f05db932c3d1c"><td class="memItemLeft" align="right" valign="top"><a id="a8f7f78972936e80cb88f05db932c3d1c" name="a8f7f78972936e80cb88f05db932c3d1c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setThreadHighPriority</b> ()</td></tr>
<tr class="memdesc:a8f7f78972936e80cb88f05db932c3d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread to a priority of -19. Priority range is -20 (highest) to 19 (lowest). <br /></td></tr>
<tr class="separator:a8f7f78972936e80cb88f05db932c3d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a precise timer to run a loop at a specified frequency, and provide monitoring options for the loop runtimes. </p>
<p>There are 2 ways of using the <a class="el" href="classSaiCommon_1_1LoopTimer.html" title="This class implements a precise timer to run a loop at a specified frequency, and provide monitoring ...">LoopTimer</a> class:</p>
<p>1 - Explicitly implement a while loop and call <a class="el" href="classSaiCommon_1_1LoopTimer.html#a5c33acfc3adf03d8f386d83f6d7824d7" title="Wait for next loop. Use in your while loop. Not needed if using LoopTimer::run(). If overtine monitor...">waitForNextLoop()</a> in it (ideally at the start of the loop) that will wait for the correct amount of time to reach the desired frequency</p>
<p>2 - Use the <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">run()</a> function, which will run a loop calling a user defined callback function at the specified frequency </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a24713e4825ca143cb28281518627871c" name="a24713e4825ca143cb28281518627871c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24713e4825ca143cb28281518627871c">&#9670;&#160;</a></span>LoopTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SaiCommon::LoopTimer::LoopTimer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_wait_nanoseconds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Loop Timer with the specified frequency and initial wait time before starting the first loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>The frequency in Hz </td></tr>
    <tr><td class="paramname">initial_wait_nanoseconds</td><td>The initial wait time in nanoseconds before starting the first loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47bc8867b871b65c153ab46c6d61716f" name="a47bc8867b871b65c153ab46c6d61716f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bc8867b871b65c153ab46c6d61716f">&#9670;&#160;</a></span>elapsedSimTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SaiCommon::LoopTimer::elapsedSimTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elapsed "simulation" time since the timer started. This corresponds to the theoretical time that should have been elapsed if the loop was running at the desired frequency, and is computed from the number of epapsed cycles and the frequency of the loop. </p>
<dl class="section return"><dt>Returns</dt><dd>time in seconds </dd></dl>

</div>
</div>
<a id="ab9007054135a9cacf52f8eb82015a2c1" name="ab9007054135a9cacf52f8eb82015a2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9007054135a9cacf52f8eb82015a2c1">&#9670;&#160;</a></span>elapsedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SaiCommon::LoopTimer::elapsedTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elapsed real time (from computer cpu clock) since the timer started. </p>
<dl class="section return"><dt>Returns</dt><dd>time in seconds </dd></dl>

</div>
</div>
<a id="a2fd893de5dca6597dbdf0832340e87c1" name="a2fd893de5dca6597dbdf0832340e87c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd893de5dca6597dbdf0832340e87c1">&#9670;&#160;</a></span>enableOvertimeMonitoring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiCommon::LoopTimer::enableOvertimeMonitoring </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_overtime_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_average_overtime_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>percentage_overtime_loops_allowed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>print_warning</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables overtime monitoring. Allows a monitoring of the overtime of the loop and makes the function waitForNextLoop return false if: 1 - the latest loop overtime is higher than max_time_ms 2 - the average loop overtime is higher than max_average_time_ms 3 - the percentage of loops with overtime is higher than percentage_allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_overtime_ms</td><td>maximum overtime allowed for a single loop in milliseconds </td></tr>
    <tr><td class="paramname">max_average_overtime_ms</td><td>maximum average overtime allowed for all loops in milliseconds </td></tr>
    <tr><td class="paramname">percentage_overtime_loops_allowed</td><td>maximum percentage of loops allowed to have overtime (between 0 and 100) </td></tr>
    <tr><td class="paramname">print_warning</td><td>whether to print a warning when one of the overtime monitor conditions is triggered (will slow down the program and worsen the overtimes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfbb552aea547d89c4ca36b62e94315d" name="acfbb552aea547d89c4ca36b62e94315d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbb552aea547d89c4ca36b62e94315d">&#9670;&#160;</a></span>reinitializeTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiCommon::LoopTimer::reinitializeTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_wait_nanoseconds</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize the timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_wait_nanoseconds</td><td>The wait time in nanoseconds before the timer starts again </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7da72aa5dac934e9a28daab42870cb83" name="a7da72aa5dac934e9a28daab42870cb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da72aa5dac934e9a28daab42870cb83">&#9670;&#160;</a></span>resetLoopFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiCommon::LoopTimer::resetLoopFrequency </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the loop frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>The frequency in Hz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f70b24a9a22d85bb558beb28441ea96" name="a0f70b24a9a22d85bb558beb28441ea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f70b24a9a22d85bb558beb28441ea96">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiCommon::LoopTimer::run </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>userCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a loop that calls the user_callback(). Blocking function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userCallback</td><td>A function to call every loop.</td></tr>
  </table>
  </dd>
</dl>
<p>Starts a loop that calls the user_callback() function at the specified frequency. This is less tested than the other method of implementing explicitely the while loop and using the <a class="el" href="classSaiCommon_1_1LoopTimer.html#a5c33acfc3adf03d8f386d83f6d7824d7" title="Wait for next loop. Use in your while loop. Not needed if using LoopTimer::run(). If overtine monitor...">waitForNextLoop()</a> function. This function is blocking and will only return when the <a class="el" href="classSaiCommon_1_1LoopTimer.html#a359c7b5ddf4356aebe8fe309cb5105a1" title="Stop the loop, started by run(). Use within callback, or from a seperate thread.">stop()</a> function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userCallback</td><td>the callback function to run at the specified frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2db79825ee463c713b70b34a0aa8c1d4" name="a2db79825ee463c713b70b34a0aa8c1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db79825ee463c713b70b34a0aa8c1d4">&#9670;&#160;</a></span>setCtrlCHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SaiCommon::LoopTimer::setCtrlCHandler </td>
          <td>(</td>
          <td class="paramtype">void(*)(int)&#160;</td>
          <td class="paramname"><em>userCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Ctrl C Handler object (untested) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userCallback</td><td>A function to call when the user presses ctrl-c. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359c7b5ddf4356aebe8fe309cb5105a1" name="a359c7b5ddf4356aebe8fe309cb5105a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359c7b5ddf4356aebe8fe309cb5105a1">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SaiCommon::LoopTimer::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the loop, started by <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">run()</a>. Use within callback, or from a seperate thread. </p>
<p>Stop the loop started by the <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">run()</a> function. This function needs to be called from within the callback function, or from a separate thread if using the <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">run()</a> function. </p>

</div>
</div>
<a id="a5c33acfc3adf03d8f386d83f6d7824d7" name="a5c33acfc3adf03d8f386d83f6d7824d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c33acfc3adf03d8f386d83f6d7824d7">&#9670;&#160;</a></span>waitForNextLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SaiCommon::LoopTimer::waitForNextLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for next loop. Use in your while loop. Not needed if using <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">LoopTimer::run()</a>. If overtine monitoring is enabled, this function will return false in case the overtime monitoring conditions are not satisfied and true otherwise. If no overtime monitoring is enabled, this will return true if the timer waited and false otherwise. </p>
<p>Wait for next loop. Use if a while loop is explicitely implemented in order to wait the correct amount of time. Not needed if using <a class="el" href="classSaiCommon_1_1LoopTimer.html#a0f70b24a9a22d85bb558beb28441ea96" title="Run a loop that calls the user_callback(). Blocking function.">LoopTimer::run()</a>. If overtine monitoring is enabled, this function will return false in case the overtime monitoring conditions are not satisfied and true otherwise. If no overtime monitoring is enabled, this will return true if the timer waited and false otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the timer waited, or if overtime monitoring is enabled and the overtime conditions are satisfied </dd>
<dd>
false if the timer did not wait, or if overtime monitoring is enabled and the overtime conditions are not satisfied </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/sai-common/sai-common/src/timer/<a class="el" href="LoopTimer_8h_source.html">LoopTimer.h</a></li>
<li>/home/runner/work/sai-common/sai-common/src/timer/<b>LoopTimer.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
